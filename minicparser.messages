prog: STRUCT IDENT BRAO TYPE IDENT SEMI BRAC SEMI WHILE
##
## Ends in an error in state: 26.
##
## prog -> struct_def . prog [ # ]
##
## The known suffix of the stack is as follows:
## struct_def
##

Unexpected instruction outside of a function body.

prog: STRUCT IDENT BRAO TYPE IDENT SEMI BRAC WHILE
##
## Ends in an error in state: 24.
##
## struct_def -> struct_prefix struct_body . SEMI [ TYPE STRUCT ]
##
## The known suffix of the stack is as follows:
## struct_prefix struct_body
##

Missing ';' after struct definition

prog: STRUCT IDENT BRAO TYPE IDENT SEMI WHILE
##
## Ends in an error in state: 22.
##
## nonempty_list(__anonymous_0) -> decl SEMI . [ BRAC ]
## nonempty_list(__anonymous_0) -> decl SEMI . nonempty_list(__anonymous_0) [ BRAC ]
##
## The known suffix of the stack is as follows:
## decl SEMI
##

Unexpected instruction outside of a function body.

prog: STRUCT IDENT BRAO TYPE IDENT WHILE
##
## Ends in an error in state: 21.
##
## nonempty_list(__anonymous_0) -> decl . SEMI [ BRAC ]
## nonempty_list(__anonymous_0) -> decl . SEMI nonempty_list(__anonymous_0) [ BRAC ]
##
## The known suffix of the stack is as follows:
## decl
##

Expecting ';' after declaration.

prog: STRUCT IDENT BRAO WHILE
##
## Ends in an error in state: 14.
##
## struct_body -> BRAO . nonempty_list(__anonymous_0) BRAC [ SEMI ]
##
## The known suffix of the stack is as follows:
## BRAO
##

Unexpected instruction outside of a function body.

prog: STRUCT IDENT TIMES WHILE
##
## Ends in an error in state: 11.
##
## nonempty_list(__anonymous_1) -> TIMES . [ IDENT ]
## nonempty_list(__anonymous_1) -> TIMES . nonempty_list(__anonymous_1) [ IDENT ]
##
## The known suffix of the stack is as follows:
## TIMES
##

Expecting identifier in pointer declaration.

prog: STRUCT IDENT WHILE
##
## Ends in an error in state: 10.
##
## decl -> struct_prefix . IDENT [ SEMI PARO EQ ]
## pointer_decl -> struct_prefix . nonempty_list(__anonymous_1) IDENT [ SEMI PARO EQ ]
## struct_def -> struct_prefix . struct_body SEMI [ TYPE STRUCT ]
##
## The known suffix of the stack is as follows:
## struct_prefix
##

Expecting identifier or '{' after struct prefix.

prog: STRUCT WHILE
##
## Ends in an error in state: 7.
##
## struct_prefix -> STRUCT . IDENT [ TIMES IDENT BRAO ]
##
## The known suffix of the stack is as follows:
## STRUCT
##

Expecting an identifier after keyword 'struct'.

prog: TYPE IDENT EQ ADDRESS WHILE
##
## Ends in an error in state: 61.
##
## address -> ADDRESS . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## ADDRESS
##

Expecting an axpression after unary operator.

prog: TYPE IDENT EQ BRAO TRUE COMMA WHILE
##
## Ends in an error in state: 113.
##
## separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ BRAC ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Unexpected instruction inside an initializer list.

prog: TYPE IDENT EQ BRAO TRUE WHILE
##
## Ends in an error in state: 86.
##
## add -> expr . PLUS expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr . AND expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## div -> expr . BY expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr . EQEQ expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr . GTH expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr . LEQ expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr . LTH expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mod_op -> expr . MOD expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mul -> expr . TIMES expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr . NEQ expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr . OR expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## separated_nonempty_list(COMMA,expr) -> expr . [ BRAC ]
## separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ BRAC ]
## sub -> expr . MINUS expr [ TIMES PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ BRAO WHILE
##
## Ends in an error in state: 60.
##
## init_list -> BRAO . loption(separated_nonempty_list(COMMA,expr)) BRAC [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## BRAO
##

Unexpected instruction inside an initializer list.

prog: TYPE IDENT EQ IDENT ARROW WHILE
##
## Ends in an error in state: 51.
##
## ptr_member_access -> access ARROW . IDENT [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ EQ DOT COMMA BY BRAC ARROW AND ]
##
## The known suffix of the stack is as follows:
## access ARROW
##

Expected an identifier after the '->' operator.

prog: TYPE IDENT EQ IDENT DOT WHILE
##
## Ends in an error in state: 49.
##
## struct_access -> access DOT . IDENT [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ EQ DOT COMMA BY BRAC ARROW AND ]
##
## The known suffix of the stack is as follows:
## access DOT
##

Expected identifier after '.' operator.

prog: TYPE IDENT EQ IDENT EQ
##
## Ends in an error in state: 82.
##
## expr -> access . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## ptr_member_access -> access . ARROW IDENT [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ DOT COMMA BY BRAC ARROW AND ]
## struct_access -> access . DOT IDENT [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ DOT COMMA BY BRAC ARROW AND ]
##
## The known suffix of the stack is as follows:
## access
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 56, spurious reduction of production get -> IDENT 
## In state 46, spurious reduction of production access -> get 
##

Expecting ';' after declaraion.

prog: TYPE IDENT EQ IDENT PARO TRUE COMMA WHILE
##
## Ends in an error in state: 116.
##
## args -> expr COMMA . args [ PARC ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Unexpected instruction inside an arguments list.

prog: TYPE IDENT EQ IDENT PARO TRUE WHILE
##
## Ends in an error in state: 115.
##
## add -> expr . PLUS expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
## and_op -> expr . AND expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
## args -> expr . [ PARC ]
## args -> expr . COMMA args [ PARC ]
## div -> expr . BY expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
## eq -> expr . EQEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
## geq -> expr . GEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
## gth -> expr . GTH expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
## leq -> expr . LEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
## lth -> expr . LTH expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
## mod_op -> expr . MOD expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
## mul -> expr . TIMES expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
## neq -> expr . NEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
## or_op -> expr . OR expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
## sub -> expr . MINUS expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY AND ]
##
## The known suffix of the stack is as follows:
## expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ IDENT PARO WHILE
##
## Ends in an error in state: 57.
##
## call -> IDENT PARO . args_opt PARC [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## IDENT PARO
##

Expecting ')' or a list of expression in a function call.

prog: TYPE IDENT EQ IDENT WHILE
##
## Ends in an error in state: 56.
##
## call -> IDENT . PARO args_opt PARC [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## get -> IDENT . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ EQ DOT COMMA BY BRAC ARROW AND ]
##
## The known suffix of the stack is as follows:
## IDENT
##

Expecting an operator or ';' after identifier.

prog: TYPE IDENT EQ MINUS TRUE WHILE
##
## Ends in an error in state: 121.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neg -> MINUS expr . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## MINUS expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ MINUS WHILE
##
## Ends in an error in state: 55.
##
## neg -> MINUS . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## MINUS
##

Expecting an expression after operator '-'.

prog: TYPE IDENT EQ NOT WHILE
##
## Ends in an error in state: 54.
##
## not -> NOT . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## NOT
##

Expecting an expression after operator '!'.

prog: TYPE IDENT EQ PARO TRUE WHILE
##
## Ends in an error in state: 123.
##
## add -> expr . PLUS expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## and_op -> expr . AND expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## div -> expr . BY expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## eq -> expr . EQEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## expr -> PARO expr . PARC [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## gth -> expr . GTH expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## leq -> expr . LEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## lth -> expr . LTH expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mod_op -> expr . MOD expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mul -> expr . TIMES expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## neq -> expr . NEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## or_op -> expr . OR expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## sub -> expr . MINUS expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
##
## The known suffix of the stack is as follows:
## PARO expr
##

Missing ';' after instruction.

prog: TYPE IDENT EQ PARO WHILE
##
## Ends in an error in state: 53.
##
## expr -> PARO . expr PARC [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## PARO
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ TIMES IDENT WHILE
##
## Ends in an error in state: 48.
##
## deref -> TIMES access . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ EQ DOT COMMA BY BRAC ARROW AND ]
## ptr_member_access -> access . ARROW IDENT [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ EQ DOT COMMA BY BRAC ARROW AND ]
## struct_access -> access . DOT IDENT [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ EQ DOT COMMA BY BRAC ARROW AND ]
##
## The known suffix of the stack is as follows:
## access
##

Expecting a ';' after a declaration.

prog: TYPE IDENT EQ TIMES WHILE
##
## Ends in an error in state: 42.
##
## deref -> TIMES . access [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ EQ DOT COMMA BY BRAC ARROW AND ]
##
## The known suffix of the stack is as follows:
## TIMES
##

Expecting expression after '*' operator.

prog: TYPE IDENT EQ TRUE AND TRUE WHILE
##
## Ends in an error in state: 112.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr AND expr . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr AND expr
##

Unexpected instruction inside an expression.

prog: TYPE IDENT EQ TRUE AND WHILE
##
## Ends in an error in state: 111.
##
## and_op -> expr AND . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr AND
##

Expecting an expression after operator '&&'.

prog: TYPE IDENT EQ TRUE BY WHILE
##
## Ends in an error in state: 93.
##
## div -> expr BY . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr BY
##

Expecting an expression after operator '/'.

prog: TYPE IDENT EQ TRUE EQEQ TRUE WHILE
##
## Ends in an error in state: 110.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr EQEQ expr . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr EQEQ expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ TRUE EQEQ WHILE
##
## Ends in an error in state: 109.
##
## eq -> expr EQEQ . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr EQEQ
##

Expecting an expression after operator '=='.

prog: TYPE IDENT EQ TRUE GEQ TRUE WHILE
##
## Ends in an error in state: 108.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr GEQ expr . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr GEQ expr
##

Unexpected instruction outside of a function body.

prog: TYPE IDENT EQ TRUE GEQ WHILE
##
## Ends in an error in state: 107.
##
## geq -> expr GEQ . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr GEQ
##

Expecting an expression after operator '>='.

prog: TYPE IDENT EQ TRUE GTH TRUE WHILE
##
## Ends in an error in state: 106.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr GTH expr . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr GTH expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ TRUE GTH WHILE
##
## Ends in an error in state: 105.
##
## gth -> expr GTH . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr GTH
##

Expecting an expression after operation '>'.

prog: TYPE IDENT EQ TRUE LEQ TRUE WHILE
##
## Ends in an error in state: 104.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr LEQ expr . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr LEQ expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ TRUE LEQ WHILE
##
## Ends in an error in state: 103.
##
## leq -> expr LEQ . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr LEQ
##

Expecting an expression after operator '<='.

prog: TYPE IDENT EQ TRUE LTH TRUE WHILE
##
## Ends in an error in state: 102.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr LTH expr . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr LTH expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ TRUE LTH WHILE
##
## Ends in an error in state: 101.
##
## lth -> expr LTH . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr LTH
##

Expecting an expression after operator '>'.

prog: TYPE IDENT EQ TRUE MINUS TRUE WHILE
##
## Ends in an error in state: 100.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## sub -> expr MINUS expr . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr MINUS expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ TRUE MINUS WHILE
##
## Ends in an error in state: 99.
##
## sub -> expr MINUS . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr MINUS
##

Expecting an expression after operator '-'.

prog: TYPE IDENT EQ TRUE MOD WHILE
##
## Ends in an error in state: 91.
##
## mod_op -> expr MOD . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr MOD
##

Expecting an expression after operator '%'.

prog: TYPE IDENT EQ TRUE NEQ TRUE WHILE
##
## Ends in an error in state: 98.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr NEQ expr . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr NEQ expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ TRUE NEQ WHILE
##
## Ends in an error in state: 97.
##
## neq -> expr NEQ . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr NEQ
##

Expecting an expression after operator '!='.

prog: TYPE IDENT EQ TRUE OR TRUE WHILE
##
## Ends in an error in state: 96.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr OR expr . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr OR expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ TRUE OR WHILE
##
## Ends in an error in state: 95.
##
## or_op -> expr OR . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr OR
##

Expecting an expression after operator '||'.

prog: TYPE IDENT EQ TRUE PLUS TRUE WHILE
##
## Ends in an error in state: 90.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## add -> expr PLUS expr . [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr PLUS expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ TRUE PLUS WHILE
##
## Ends in an error in state: 89.
##
## add -> expr PLUS . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr PLUS
##

Expecting an expression after operator '+'.

prog: TYPE IDENT EQ TRUE TIMES WHILE
##
## Ends in an error in state: 87.
##
## mul -> expr TIMES . expr [ TIMES SEMI PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ COMMA BY BRAC AND ]
##
## The known suffix of the stack is as follows:
## expr TIMES
##

Expecting an expression after operator '*'.

prog: TYPE IDENT EQ TRUE WHILE
##
## Ends in an error in state: 179.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## option(__anonymous_3) -> EQ expr . [ SEMI ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
##
## The known suffix of the stack is as follows:
## EQ expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT EQ WHILE
##
## Ends in an error in state: 178.
##
## option(__anonymous_3) -> EQ . expr [ SEMI ]
##
## The known suffix of the stack is as follows:
## EQ
##

Expecting an expression after operator '='.

prog: TYPE IDENT PARO PARC BRAO CONST SEMI BRAC TYPE IDENT WHILE
##
## Ends in an error in state: 34.
##
## func -> decl . PARO params_opt PARC BRAO body BRAC [ TYPE STRUCT EOF ]
##
## The known suffix of the stack is as follows:
## decl
##

Expecting '(' after function declaration.

prog: TYPE IDENT PARO PARC BRAO CONST SEMI BRAC WHILE
##
## Ends in an error in state: 31.
##
## funcs -> funcs . func [ TYPE STRUCT EOF ]
## suite_prog -> funcs . EOF [ # ]
##
## The known suffix of the stack is as follows:
## funcs
##

Unexpected instruction outside of function body.

prog: TYPE IDENT PARO PARC BRAO IDENT EQ TRUE WHILE
##
## Ends in an error in state: 165.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## set -> access EQ expr . SEMI [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
##
## The known suffix of the stack is as follows:
## access EQ expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT PARO PARC BRAO IDENT EQ WHILE
##
## Ends in an error in state: 164.
##
## set -> access EQ . expr SEMI [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## access EQ
##

Expecting an expression after operator '='.

prog: TYPE IDENT PARO PARC BRAO IDENT PARC
##
## Ends in an error in state: 163.
##
## expr -> access . [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## ptr_member_access -> access . ARROW IDENT [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ EQ DOT BY ARROW AND ]
## set -> access . EQ expr SEMI [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## struct_access -> access . DOT IDENT [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ EQ DOT BY ARROW AND ]
##
## The known suffix of the stack is as follows:
## access
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 56, spurious reduction of production get -> IDENT 
## In state 46, spurious reduction of production access -> get 
##

Unexpected instruction inside an expression.

prog: TYPE IDENT PARO PARC BRAO IF PARO TRUE PARC BRAO SEMI
##
## Ends in an error in state: 140.
##
## ifi -> IF PARO expr PARC BRAO . body BRAC ELSE BRAO body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## IF PARO expr PARC BRAO
##

Expecting instructions inside 'if' body.

prog: TYPE IDENT PARO PARC BRAO IF PARO TRUE PARC BRAO TRUE SEMI BRAC ELSE BRAO SEMI
##
## Ends in an error in state: 158.
##
## ifi -> IF PARO expr PARC BRAO body BRAC ELSE BRAO . body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## IF PARO expr PARC BRAO body BRAC ELSE BRAO
##

Expecting instructions inside 'else' body.

prog: TYPE IDENT PARO PARC BRAO IF PARO TRUE PARC BRAO TRUE SEMI BRAC ELSE BRAO TRUE SEMI SEMI
##
## Ends in an error in state: 159.
##
## body -> body . instr [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## body -> body . local [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## ifi -> IF PARO expr PARC BRAO body BRAC ELSE BRAO body . BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## IF PARO expr PARC BRAO body BRAC ELSE BRAO body
##

Expecting '}' at the end of a block.

prog: TYPE IDENT PARO PARC BRAO IF PARO TRUE PARC BRAO TRUE SEMI BRAC ELSE WHILE
##
## Ends in an error in state: 157.
##
## ifi -> IF PARO expr PARC BRAO body BRAC ELSE . BRAO body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## IF PARO expr PARC BRAO body BRAC ELSE
##

Expecting '{' after keyword 'else'.

prog: TYPE IDENT PARO PARC BRAO IF PARO TRUE PARC BRAO TRUE SEMI BRAC WHILE
##
## Ends in an error in state: 156.
##
## ifi -> IF PARO expr PARC BRAO body BRAC . ELSE BRAO body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## IF PARO expr PARC BRAO body BRAC
##

Expecting 'else' after 'if' block.

prog: TYPE IDENT PARO PARC BRAO IF PARO TRUE PARC BRAO TRUE SEMI SEMI
##
## Ends in an error in state: 155.
##
## body -> body . instr [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## body -> body . local [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## ifi -> IF PARO expr PARC BRAO body . BRAC ELSE BRAO body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## IF PARO expr PARC BRAO body
##

Expecting '}' at the end of a block.

prog: TYPE IDENT PARO PARC BRAO IF PARO TRUE PARC WHILE
##
## Ends in an error in state: 139.
##
## ifi -> IF PARO expr PARC . BRAO body BRAC ELSE BRAO body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## IF PARO expr PARC
##

Expecting '{' after if condition.

prog: TYPE IDENT PARO PARC BRAO IF PARO TRUE WHILE
##
## Ends in an error in state: 138.
##
## add -> expr . PLUS expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## and_op -> expr . AND expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## div -> expr . BY expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## eq -> expr . EQEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## geq -> expr . GEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## gth -> expr . GTH expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## ifi -> IF PARO expr . PARC BRAO body BRAC ELSE BRAO body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## leq -> expr . LEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## lth -> expr . LTH expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mod_op -> expr . MOD expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mul -> expr . TIMES expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## neq -> expr . NEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## or_op -> expr . OR expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## sub -> expr . MINUS expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
##
## The known suffix of the stack is as follows:
## IF PARO expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT PARO PARC BRAO IF PARO WHILE
##
## Ends in an error in state: 137.
##
## ifi -> IF PARO . expr PARC BRAO body BRAC ELSE BRAO body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## IF PARO
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT PARO PARC BRAO IF WHILE
##
## Ends in an error in state: 136.
##
## ifi -> IF . PARO expr PARC BRAO body BRAC ELSE BRAO body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## IF
##

Expecting '(' after the keyword 'if'.

prog: TYPE IDENT PARO PARC BRAO PUTCHAR PARO TRUE PARC WHILE
##
## Ends in an error in state: 134.
##
## putchar -> PUTCHAR PARO expr PARC . SEMI [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## PUTCHAR PARO expr PARC
##

Expecting ';' after an instruction.

prog: TYPE IDENT PARO PARC BRAO PUTCHAR PARO TRUE WHILE
##
## Ends in an error in state: 133.
##
## add -> expr . PLUS expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## and_op -> expr . AND expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## div -> expr . BY expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## eq -> expr . EQEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## geq -> expr . GEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## gth -> expr . GTH expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## leq -> expr . LEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## lth -> expr . LTH expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mod_op -> expr . MOD expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mul -> expr . TIMES expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## neq -> expr . NEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## or_op -> expr . OR expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## putchar -> PUTCHAR PARO expr . PARC SEMI [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## sub -> expr . MINUS expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
##
## The known suffix of the stack is as follows:
## PUTCHAR PARO expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT PARO PARC BRAO PUTCHAR PARO WHILE
##
## Ends in an error in state: 132.
##
## putchar -> PUTCHAR PARO . expr PARC SEMI [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## PUTCHAR PARO
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT PARO PARC BRAO PUTCHAR WHILE
##
## Ends in an error in state: 131.
##
## putchar -> PUTCHAR . PARO expr PARC SEMI [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## PUTCHAR
##

Expecting '(' after keyword 'putchar'.

prog: TYPE IDENT PARO PARC BRAO RETURN TRUE WHILE
##
## Ends in an error in state: 129.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## returni -> RETURN expr . SEMI [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
##
## The known suffix of the stack is as follows:
## RETURN expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT PARO PARC BRAO RETURN WHILE
##
## Ends in an error in state: 128.
##
## returni -> RETURN . expr SEMI [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## RETURN
##

Expecting an expression after keyword 'return'.

prog: TYPE IDENT PARO PARC BRAO SEMI
##
## Ends in an error in state: 38.
##
## func -> decl PARO params_opt PARC BRAO . body BRAC [ TYPE STRUCT EOF ]
##
## The known suffix of the stack is as follows:
## decl PARO params_opt PARC BRAO
##

Expecting an instruction inside function body.

prog: TYPE IDENT PARO PARC BRAO TRUE SEMI SEMI
##
## Ends in an error in state: 169.
##
## body -> body . instr [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## body -> body . local [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## func -> decl PARO params_opt PARC BRAO body . BRAC [ TYPE STRUCT EOF ]
##
## The known suffix of the stack is as follows:
## decl PARO params_opt PARC BRAO body
##

Expecting '}' at the end of a function body.

prog: TYPE IDENT PARO PARC BRAO TRUE WHILE
##
## Ends in an error in state: 148.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## instr -> expr . SEMI [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
##
## The known suffix of the stack is as follows:
## expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT PARO PARC BRAO TYPE IDENT EQ TRUE WHILE
##
## Ends in an error in state: 152.
##
## add -> expr . PLUS expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## and_op -> expr . AND expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## div -> expr . BY expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## eq -> expr . EQEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## geq -> expr . GEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## gth -> expr . GTH expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## leq -> expr . LEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## lth -> expr . LTH expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mod_op -> expr . MOD expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mul -> expr . TIMES expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## neq -> expr . NEQ expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## option(__anonymous_4) -> EQ expr . [ SEMI ]
## or_op -> expr . OR expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## sub -> expr . MINUS expr [ TIMES SEMI PLUS OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
##
## The known suffix of the stack is as follows:
## EQ expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT PARO PARC BRAO TYPE IDENT EQ WHILE
##
## Ends in an error in state: 151.
##
## option(__anonymous_4) -> EQ . expr [ SEMI ]
##
## The known suffix of the stack is as follows:
## EQ
##

Expecting an expression after operator '='.

prog: TYPE IDENT PARO PARC BRAO TYPE IDENT WHILE
##
## Ends in an error in state: 150.
##
## local -> decl . option(__anonymous_4) SEMI [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## decl
##

Expecting ';' after variable declaration.

prog: TYPE IDENT PARO PARC BRAO WHILE PARO TRUE PARC BRAO SEMI
##
## Ends in an error in state: 127.
##
## whilei -> WHILE PARO expr PARC BRAO . body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## WHILE PARO expr PARC BRAO
##

Expecting instructions inside a 'while' body.

prog: TYPE IDENT PARO PARC BRAO WHILE PARO TRUE PARC BRAO TRUE SEMI SEMI
##
## Ends in an error in state: 167.
##
## body -> body . instr [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## body -> body . local [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
## whilei -> WHILE PARO expr PARC BRAO body . BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## WHILE PARO expr PARC BRAO body
##

Expecting '}' after the end of a block.

prog: TYPE IDENT PARO PARC BRAO WHILE PARO TRUE PARC WHILE
##
## Ends in an error in state: 126.
##
## whilei -> WHILE PARO expr PARC . BRAO body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## WHILE PARO expr PARC
##

Expecting '(' after the 'while' condition.

prog: TYPE IDENT PARO PARC BRAO WHILE PARO TRUE WHILE
##
## Ends in an error in state: 125.
##
## add -> expr . PLUS expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## and_op -> expr . AND expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## div -> expr . BY expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## eq -> expr . EQEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## geq -> expr . GEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## gth -> expr . GTH expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## leq -> expr . LEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## lth -> expr . LTH expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mod_op -> expr . MOD expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## mul -> expr . TIMES expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## neq -> expr . NEQ expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## or_op -> expr . OR expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## sub -> expr . MINUS expr [ TIMES PLUS PARC OR NEQ MOD MINUS LTH LEQ GTH GEQ EQEQ BY AND ]
## whilei -> WHILE PARO expr . PARC BRAO body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## WHILE PARO expr
##

Unexpected instruction inside of an expression.

prog: TYPE IDENT PARO PARC BRAO WHILE PARO WHILE
##
## Ends in an error in state: 40.
##
## whilei -> WHILE PARO . expr PARC BRAO body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## WHILE PARO
##

Expecting an expression inside the while condition.

prog: TYPE IDENT PARO PARC BRAO WHILE WHILE
##
## Ends in an error in state: 39.
##
## whilei -> WHILE . PARO expr PARC BRAO body BRAC [ WHILE TYPE TRUE TIMES STRUCT RETURN PUTCHAR PARO NOT MINUS IF IDENT FALSE CONST BRAO BRAC ADDRESS ]
##
## The known suffix of the stack is as follows:
## WHILE
##

Expecting '(' after keyword 'while'.

prog: TYPE IDENT PARO PARC WHILE
##
## Ends in an error in state: 37.
##
## func -> decl PARO params_opt PARC . BRAO body BRAC [ TYPE STRUCT EOF ]
##
## The known suffix of the stack is as follows:
## decl PARO params_opt PARC
##

Expecting a '{' after a function prototype.

prog: TYPE IDENT PARO TYPE IDENT COMMA WHILE
##
## Ends in an error in state: 173.
##
## params -> param COMMA . params [ PARC ]
##
## The known suffix of the stack is as follows:
## param COMMA
##

Expecting a declaration after ','.

prog: TYPE IDENT PARO TYPE IDENT WHILE
##
## Ends in an error in state: 172.
##
## params -> param . [ PARC ]
## params -> param . COMMA params [ PARC ]
##
## The known suffix of the stack is as follows:
## param
##

Expecting ')' at the end of parameters list.

prog: TYPE IDENT PARO WHILE
##
## Ends in an error in state: 35.
##
## func -> decl PARO . params_opt PARC BRAO body BRAC [ TYPE STRUCT EOF ]
##
## The known suffix of the stack is as follows:
## decl PARO
##

Expecting ')' at the end of parameters list.

prog: TYPE IDENT SEMI STRUCT IDENT WHILE
##
## Ends in an error in state: 15.
##
## decl -> struct_prefix . IDENT [ SEMI PARO PARC EQ COMMA ]
## pointer_decl -> struct_prefix . nonempty_list(__anonymous_1) IDENT [ SEMI PARO PARC EQ COMMA ]
##
## The known suffix of the stack is as follows:
## struct_prefix
##

Expecting an identifier in global declaration.

prog: TYPE IDENT SEMI WHILE
##
## Ends in an error in state: 29.
##
## suite_prog -> glob_var SEMI . suite_prog [ # ]
##
## The known suffix of the stack is as follows:
## glob_var SEMI
##

Unexpected instruction outside of a function body.

prog: TYPE IDENT WHILE
##
## Ends in an error in state: 177.
##
## func -> decl . PARO params_opt PARC BRAO body BRAC [ TYPE STRUCT EOF ]
## glob_var -> decl . option(__anonymous_3) [ SEMI ]
##
## The known suffix of the stack is as follows:
## decl
##

Expecting ';' after global declaration.

prog: TYPE TIMES WHILE
##
## Ends in an error in state: 2.
##
## nonempty_list(__anonymous_2) -> TIMES . [ IDENT ]
## nonempty_list(__anonymous_2) -> TIMES . nonempty_list(__anonymous_2) [ IDENT ]
##
## The known suffix of the stack is as follows:
## TIMES
##

Expecting an identifier inside a pointer declaration.

prog: TYPE WHILE
##
## Ends in an error in state: 1.
##
## decl -> TYPE . IDENT [ SEMI PARO PARC EQ COMMA ]
## pointer_decl -> TYPE . nonempty_list(__anonymous_2) IDENT [ SEMI PARO PARC EQ COMMA ]
##
## The known suffix of the stack is as follows:
## TYPE
##

Expecting an identifier after a type.

prog: WHILE
##
## Ends in an error in state: 0.
##
## prog' -> . prog [ # ]
##
## The known suffix of the stack is as follows:
##
##

Unexpected instruction outside of function body.

